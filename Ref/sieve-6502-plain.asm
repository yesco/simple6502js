.LIF
*---------------------------------
*      SIEVE PROGRAM:
*      CALCULATES FIRST 1899 PRIMES IN 1.39 SECONDS!
*
*      INSPIRED BY JIM GILBREATH, BYTE, 9/81
*
*      WRITTEN BY WILLIAM ROBERT SAVOIE
*                 4405 DELASHMITT RD. APT 15
*                 HIXSON, TENN  37343
*---------------------------------
BUFF   .EQ $3500    START OF BUFFER (#BUFF=0)
SIZE   .EQ 8189     SIZE OF FLAG ARRAY
*---------------------------------
*      PAGE-ZERO VARIABLES
*---------------------------------
INDEX  .EQ $06      PAGE ZERO INDEX (LOCATION FOR I)
PRIME  .EQ $08      PRIME LOCATION
KVAR   .EQ $19      K VARIABLE 
CVAR   .EQ $1B      COUNT OF PRIME
ARRAY  .EQ $1D      ARRAY POINTER
SAVE   .EQ $1F      COUNT LOOP
*---------------------------------
*      ROM ROUTINES
*---------------------------------
HOME   .EQ $FC58    CLEAR VIDEO
CR     .EQ $FD8E    CARRIAGE RETURN
LINE   .EQ $FD9E    PRINT "-"
PRINTN .EQ $F940    PRINT 2 BYTE NUMBER IN HEX
BELL   .EQ $FBE2    SOUND BELL WHEN DONE
*---------------------------------
* RUN PROGRAM 100 TIMES FOR ACCURATE TIME MEASUREMENTS!
*---------------------------------
START  JSR HOME     CLEAR SCREEN
       JSR CR       CARRIAGE RETURN
       LDA #100     LOOP 100 TIMES
       STA SAVE     SET COUNTER
.01    JSR GO       RUN PRIME
       DEC SAVE     DECREASE SAVE
       BNE .01      LOOP
       JSR PRINT    PRINT COUNT
       JSR BELL     READ WATCH!
       RTS
*---------------------------------
*      RESET VARIABLES
*---------------------------------
GO     LDY #00      CLEAR INDEX
       STY CVAR     CLEAR COUNT VARIABLE
       STY CVAR+1   HI BYTE TOO
       STY INDEX    CLEAR INDEX
       STY INDEX+1  HI BYTE TOO
       STY ARRAY    LOW BYTE OF ARRAY
       LDA /BUFF    GET BUFFER LOCATION
       STA ARRAY+1  SET ARRAY POINTER
       LDA #$01     LOAD WITH ONE
       LDX /SIZE    LOAD STOP BYTE
       INX          MAKE PAGE LARGER
*---------------------------------
*      SET EACH ELEMENT IN ARRAY TO ONE
*---------------------------------
SET    STA (ARRAY),Y  SET MEMORY
       DEY          NEXT LOCATION
       BNE SET      GO 256 TIMES
       INC ARRAY+1  MOVE ARRAY INDEX
       DEX          TEST END
       BNE SET      GO TELL END

* SET ARRAY INDEX AT START OF BUFFER
       LDA #BUFF    SET BUFFER LOCATION
       STA ARRAY    IN ARRAY POINTER LOW
       LDA /BUFF    SET BUFFER LOCATION
       STA ARRAY+1  IN ARRAY POINTER
       JMP FORIN    ENTER SIEVE ALGORITHM

* SCAN ENTIRE ARRAY AND PROBAGATE LAST PRIME
FORNXT INC INDEX    INCREASE LOW BYTE
       BNE FORIN    GO IF < 256
       INC INDEX+1  INCREASE HI BYTE
FORIN  LDA INDEX    GET INDEX TO ARRAY
       CLC          READY ADD
       STA ARRAY    SAVE LOW BYTE
       LDA INDEX+1  GET HI BYTE
       ADC /BUFF    ADD BUFFER LOCATION
       STA ARRAY+1  SET POINTER
       LDY #00      CLEAR Y REGISTER
       LDA (ARRAY),Y  GET ARRAY VALUE 
       BEQ FORNXT   GO IF FLAG=0 SINCE NOT PRIME
* CALCULATE NEXT PRIME NUMBER WITH P=I+I+3
       LDA INDEX    MAKE P=I+3
       ADC #03      ADD THREE
       STA PRIME
       LDA INDEX+1
       ADC #00      ADD CARRY
       STA PRIME+1
* NOW P=I+3
       LDA PRIME
       ADC INDEX    MAKE P=P+I 
       STA PRIME
       LDA PRIME+1
       ADC INDEX+1  ADD HI BYTE
       STA PRIME+1  SAVE P

* NOW CALCULATE K=I+PRIME (CLEAR BEYOND PRIME)
       LDA INDEX    ADD I TO P
       ADC PRIME
       STA KVAR     SAVE IN K
       LDA INDEX+1
       ADC PRIME+1  ADD HI BYTE TOO
       STA KVAR+1   SAVE K VALUE

* SEE IF K > SIZE AND MODIFY ARRAY IF NOT
.02    LDA KVAR     GET K VAR
       SEC          SET CARRY FOR SUB
       SBC #SIZE    SUBTRACT SIZE
       LDA KVAR+1   GET HI BYTE
       SBC /SIZE    SUBTRACT TOO
       BCS .03      GO IF K < SIZE
* ASSIGN ARRAY(K)=0 SINCE PRIME CAN BE ADDED TO MAKE NUMBER
* THEREFORE THIS CANNOT BE PRIME! (PROBAGATE THROUGH ARRAY)
       LDA KVAR     GET INDEX TO ARRAY
       STA ARRAY    SAVE LOW BYTE
       LDA KVAR+1   GET HI BYTE
       ADC /BUFF    ADD BUFFER OFFSET
       STA ARRAY+1  SAVE ARRAY INDEX
       LDA #00      CLEAR A
       TAY          AND Y REGISTER
       STA (ARRAY),Y  CLEAR ARRAY LOCATION
* CREATE NEW K FROM K=K+PRIME (MOVE THROUGH ARRAY)
       LDA KVAR     GET K LOW
       ADC PRIME    ADD PRIME
       STA KVAR     SAVE K
       LDA KVAR+1   NOW ADD HI BYTES
       ADC PRIME+1
       STA KVAR+1
       JMP .02      LOOP TELL ARRAY DONE
* NOW COUNT PRIMES FOUND  (C=C+1)
.03
* --NOTE-- DELETE NEXT LINE TO TIME PROGRAM (JSR PRINTP)
       JSR PRINTP   PRINT PRIME
       INC CVAR     ADD ONE
       BNE .04      GO IF NO OVERFLOW
       INC CVAR+1   HI BYTE COUNTER
.04    LDA INDEX    GET INDEX
* TEST TO SEE IF WE HAVE INDEXED THROUGH ENTIRE ARRAY
       SBC #SIZE    SUBTRACT SIZE
       LDA INDEX+1  GET HI BYTE TOO
       SBC /SIZE    SUBTRACT HI BYTE
       BCC FORNXT   CONTINUE?
       RTS
*---------------------------------
* PRINT THE NUMBER OF PRIMES FOUND
*---------------------------------
PRINT  LDY CVAR+1   GET HI BYTE OF COUNT
       LDX CVAR
       JSR PRINTN   PRINT PRIMES FOUND
       RTS          JOB DONE, RETURN
*---------------------------------
*      PRINT THE PRIME NUMBER (OPTIONAL)
*---------------------------------
PRINTP LDY PRIME+1  HI BYTE 
       LDX PRIME
       JSR PRINTN
       JSR LINE     VIDEO "-" OUT
       SEC
       RTS

