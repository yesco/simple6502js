;; jsk:
;;
;; ca65 Play/4param-recur.asm.saved -l Play/4param-recur.asm.lst
;;
ca65 V2.18 - N/A
Main file   : Play/4param-recur.asm
Current file: Play/4param-recur.asm

000000r 1               .zeropage
000000r 1  xx           		sp: .res 1
000001r 1  xx           		r0: .res 1
000002r 1  xx           		r1: .res 1
000003r 1  xx           		r2: .res 1
000004r 1  xx           		r3: .res 1
000005r 1  xx           		r4: .res 1
000006r 1  xx           		r5: .res 1
000007r 1  xx           		r6: .res 1
000008r 1  xx           		r7: .res 1
000009r 1  xx           		r8: .res 1
00000Ar 1  xx           		r9: .res 1
00000Br 1  xx           		r10: .res 1
00000Cr 1  xx           		r11: .res 1
00000Dr 1  xx           		r12: .res 1
00000Er 1  xx           		r13: .res 1
00000Fr 1  xx           		r14: .res 1
000010r 1  xx           		r15: .res 1
000011r 1  xx           		r16: .res 1
000012r 1  xx           		r17: .res 1
000013r 1  xx           		r18: .res 1
000014r 1  xx           		r19: .res 1
000015r 1  xx           		r20: .res 1
000016r 1  xx           		r21: .res 1
000017r 1  xx           		r22: .res 1
000018r 1  xx           		r23: .res 1
000019r 1  xx           		r24: .res 1
00001Ar 1  xx           		r25: .res 1
00001Br 1  xx           		r26: .res 1
00001Cr 1  xx           		r27: .res 1
00001Dr 1  xx           		r28: .res 1
00001Er 1  xx           		r29: .res 1
00001Fr 1  xx           		r30: .res 1
000020r 1  xx           		r31: .res 1
000021r 1  xx           		btmp0: .res 1
000022r 1  xx           		btmp1: .res 1
000023r 1  xx           		btmp2: .res 1
000024r 1  xx           		btmp3: .res 1
000025r 1               .code
000000r 1               
000000r 1               _fun:
;; 12 B adjusting sp: sp-= 8
000000r 1  38           	sec
000001r 1  A5 rr        	lda	sp
000003r 1  E9 08        	sbc	#8
000005r 1  85 rr        	sta	sp
000007r 1  B0 02        	bcs	l10
000009r 1  C6 rr        	dec	sp+1
00000Br 1               l10:

;; save current! (never restored lol)

;; push(r0/1)
;; 11 B
00000Br 1  A5 rr        	lda	r1
00000Dr 1  A0 01        	ldy	#1
00000Fr 1  91 rr        	sta	(sp),y
000011r 1  A5 rr        	lda	r0
000013r 1  88           	dey
000014r 1  91 rr        	sta	(sp),y

;; push(r2/3)
000016r 1  A5 rr        	lda	r3
000018r 1  A0 03        	ldy	#3
00001Ar 1  91 rr        	sta	(sp),y
00001Cr 1  A5 rr        	lda	r2
00001Er 1  88           	dey
00001Fr 1  91 rr        	sta	(sp),y

;; push(r4/5)
000021r 1  A5 rr        	lda	r5
000023r 1  A0 05        	ldy	#5
000025r 1  91 rr        	sta	(sp),y
000027r 1  A5 rr        	lda	r4
000029r 1  88           	dey
00002Ar 1  91 rr        	sta	(sp),y

;; push(r6/7)
00002Cr 1  A5 rr        	lda	r7
00002Er 1  A0 07        	ldy	#7
000030r 1  91 rr        	sta	(sp),y
000032r 1  A5 rr        	lda	r6
000034r 1  88           	dey
000035r 1  91 rr        	sta	(sp),y

;; fun:

;; IF (a) l3; else l4;

;; get 0th argument (a)
;; 5 B
000037r 1  A0 00        	ldy	#0
000039r 1  B1 rr        	lda	(sp),y
00003Br 1  C8           	iny
;; if ..
00003Cr 1  11 rr        	ora	(sp),y
00003Er 1  F0 55        	beq	l4
000040r 1               l3:



;; preparing arguments for call


;; AX= 2; // lol for division!
000040r 1  A9 00        	lda	#0
000042r 1  85 rr        	sta	r3
000044r 1  A9 02        	lda	#2
000046r 1  85 rr        	sta	r2
;; r6/7= d/2;  //  seriously? ... ___divint16 to get /2 ???
000048r 1  A0 07        	ldy	#7
00004Ar 1  B1 rr        	lda	(sp),y
00004Cr 1  85 rr        	sta	r1
00004Er 1  88           	dey
00004Fr 1  B1 rr        	lda	(sp),y
000051r 1  85 rr        	sta	r0
000053r 1               ;	jsr	___divint16
000053r 1  20 FF FF             jsr     $ffff
000056r 1  85 rr        	sta	r6
000058r 1  86 rr        	stx	r7

;; r4/5= c*2;  // ok shift
00005Ar 1  A0 05        	ldy	#5
00005Cr 1  B1 rr        	lda	(sp),y
00005Er 1  AA           	tax
00005Fr 1  88           	dey
000060r 1  B1 rr        	lda	(sp),y
000062r 1  86 rr        	stx	r31
000064r 1  0A           	asl
000065r 1  26 rr        	rol	r31
000067r 1  A6 rr        	ldx	r31
000069r 1  85 rr        	sta	r4
00006Br 1  86 rr        	stx	r5

;; r2/3= b+1
00006Dr 1  88           	dey
00006Er 1  B1 rr        	lda	(sp),y
000070r 1  AA           	tax
000071r 1  88           	dey
000072r 1  B1 rr        	lda	(sp),y
000074r 1  18           	clc
000075r 1  69 01        	adc	#1
000077r 1  90 01        	bcc	l11
000079r 1  E8           	inx
00007Ar 1               l11:
00007Ar 1  85 rr        	sta	r2
00007Cr 1  86 rr        	stx	r3

;; r0/1= a-1;  //  lol
00007Er 1  88           	dey
00007Fr 1  B1 rr        	lda	(sp),y
000081r 1  AA           	tax
000082r 1  88           	dey
000083r 1  B1 rr        	lda	(sp),y
000085r 1  38           	sec
000086r 1  E9 01        	sbc	#1
000088r 1  B0 01        	bcs	l12
00008Ar 1  CA           	dex
00008Br 1               l12:
00008Br 1  85 rr        	sta	r0
00008Dr 1  86 rr        	stx	r1

;; fun() recursive call (r0/1, r2/3, r4/5, r6/7)
00008Fr 1  20 rr rr     	jsr	_fun

;; return?
000092r 1  4C rr rr     	jmp	l5

000095r 1               l4:

;; a+b+c+d
;; d+
000095r 1  A0 00        	ldy	#0
000097r 1  B1 rr        	lda	(sp),y
000099r 1  18           	clc
00009Ar 1  A0 02        	ldy	#2
00009Cr 1  71 rr        	adc	(sp),y
00009Er 1  85 rr        	sta	r0
;; c?
0000A0r 1  88           	dey
0000A1r 1  B1 rr        	lda	(sp),y
0000A3r 1  A0 03        	ldy	#3
0000A5r 1  71 rr        	adc	(sp),y
0000A7r 1  85 rr        	sta	r1
0000A9r 1  A5 rr        	lda	r0
0000ABr 1  18           	clc
;; b
0000ACr 1  C8           	iny
0000ADr 1  71 rr        	adc	(sp),y
0000AFr 1  85 rr        	sta	r0
0000B1r 1  A5 rr        	lda	r1
0000B3r 1  C8           	iny
;; a
0000B4r 1  71 rr        	adc	(sp),y
0000B6r 1  85 rr        	sta	r1
0000B8r 1  A5 rr        	lda	r0
0000BAr 1  18           	clc
0000BBr 1  C8           	iny
0000BCr 1  71 rr        	adc	(sp),y

;; pha/pla to save temp value (can't use Y)
0000BEr 1  48           	pha
0000BFr 1  A5 rr        	lda	r1
0000C1r 1  C8           	iny
0000C2r 1  71 rr        	adc	(sp),y
0000C4r 1  AA           	tax
0000C5r 1  68           	pla
;;

;; it's not restoring anything from the stack
;; which is funny...
;; it puts the stuff there...

;; I guess it "correctly" identifies the tail-recursion
;; and knows that after the funciton call the variables
;; are "dead"!!!


0000C6r 1               l5:
0000C6r 1               l1:
;; give back stack: sp+= 8;
;; 12 B
0000C6r 1  85 rr        	sta	r31
0000C8r 1  18           	clc
0000C9r 1  A5 rr        	lda	sp
0000CBr 1  69 08        	adc	#8
0000CDr 1  85 rr        	sta	sp
0000CFr 1  90 02        	bcc	l13
0000D1r 1  E6 rr        	inc	sp+1
0000D3r 1               l13:
;; return r31/r30?
;; 3 B
0000D3r 1  A5 rr        	lda	r31
0000D5r 1  60           	rts


0000D6r 1               ; stacksize=0+??
0000D6r 1               ;	section	text
0000D6r 1               ;	global	_main
0000D6r 1               _main:

;; Parameters are saved in register r0--r7
;;
0000D6r 1  A9 FF        	lda	#255
0000D8r 1  85 rr        	sta	r7
0000DAr 1  85 rr        	sta	r6
0000DCr 1  A9 00        	lda	#0
0000DEr 1  85 rr        	sta	r5
0000E0r 1  A9 01        	lda	#1
0000E2r 1  85 rr        	sta	r4
0000E4r 1  A9 00        	lda	#0
0000E6r 1  85 rr        	sta	r3
0000E8r 1  85 rr        	sta	r2
0000EAr 1  85 rr        	sta	r1
0000ECr 1  85 rr        	sta	r0
0000EEr 1  20 rr rr     	jsr	_fun
0000F1r 1               l14:
0000F1r 1  60           	rts
0000F2r 1               ; stacksize=0+??
0000F2r 1               ;	global	___divint16
0000F2r 1               
