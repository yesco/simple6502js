// generated by Google AI, no copyright
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

/* MeteoriC 6502 Seed Date: Jul 27 22:11:58 2025 */
#define START_EPOCH 1753629118 

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>

#define START_EPOCH 1753629118
#define DICT_PATH "./5-letter-words.lst"

char *dict_buf = NULL;
size_t dict_size = 0;

void load_dict() {
  FILE *f = fopen(DICT_PATH, "r");
  if (!f) return;
  struct stat st;
  stat(DICT_PATH, &st);
  dict_size = st.st_size;
  dict_buf = malloc(dict_size + 2);
  dict_buf[0] = '\n'; // Leading newline for boundary matching
  fread(dict_buf + 1, 1, dict_size, f);
  dict_buf[dict_size + 1] = '\0';
  fclose(f);
}

int is_word(const char *w) {
  if (!dict_buf) return 0;
  char search[8];
  snprintf(search, sizeof(search), "\n%s\n", w);
  // memmem is faster than strstr for large buffers
  return memmem(dict_buf, dict_size, search, strlen(search)) != NULL;
}

void find_words(long start_min, int limit_days, time_t now) {
  char b26[6];
  long end_min = start_min + (limit_days * 1440);
  load_dict();
    
  printf("Scanning next %d days for MeteoriC milestones...\n", limit_days);
  for (long i = start_min; i < end_min; i++) {
    for (int j = 4, n = i; j >= 0; j--) {
      b26[j] = 'a' + (n % 26); n /= 26;
    }
    b26[5] = '\0';
        
    if (is_word(b26)) {
      time_t t_raw = START_EPOCH + (i * 60);
      struct tm *t = localtime(&t_raw);
      long mnow= (t_raw - now)/60;
      int m= mnow % 60, h= mnow/60 % 24, d= mnow/24/60;
      printf("%02d%02d%02d_%02d%02d\t@%s\t%3dd+%02d:%02d\n", 
             t->tm_year % 100, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, b26,
             d, h, m);
    }
  }
  free(dict_buf);
}

void to_base(long n, int base, char *out) {
  char digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
  char alpha[]  = "abcdefghijklmnopqrstuvwxyz";
  for (int i = 4; i >= 0; i--) {
    if (base == 26) out[i] = alpha[n % 26];
    else out[i] = digits[n % 36];
    n /= base;
  }
  out[5] = '\0';
}

long from_base(char *s, int base) {
  long val = 0;
  for (int i = 0; s[i] != '\0'; i++) {
    int v;
    char c = tolower(s[i]);
    if (isdigit(c)) v = c - '0';
    else v = c - 'a' + (base == 36 ? 10 : 0);
    val = val * base + v;
  }
  return val;
}

void process_type(long target_epoch, char type) {
  time_t now = time(NULL);
  struct tm *t = localtime(&target_epoch);
  char date_str[16], b26[6], b36[6], remain_str[32];
    
  long diff_mins = (target_epoch - START_EPOCH) / 60;
  if (diff_mins < 0) diff_mins = 0;

  strftime(date_str, sizeof(date_str), "%y%m%d_%H%M", t);
  to_base(diff_mins, 26, b26);
  to_base(diff_mins, 36, b36);

  long remain = target_epoch - now;
  if (labs(remain) < 30) { // Within 30 seconds of now
    sprintf(remain_str, "---");
  } else if (remain < 0) {
    sprintf(remain_str, "PAST");
  } else {
    long d = remain / 86400;
    long h = (remain % 86400) / 3600;
    long m = (remain % 3600) / 60;
    sprintf(remain_str, "%ldd %02ldh %02ldm", d, h, m);
  }

  if (type=='@') printf("@%s\n", b26);
  else if (type=='%') printf("%%%s\n", b36);
  else printf("%s\t@%s\t%%%s\t%s\n", date_str, b26, b36, remain_str);
}

void process(long target_epoch) {
  process_type(target_epoch, 0);
}

int main(int argc, char *argv[]) {
  time_t now = time(NULL);

  if (argc < 2) {
    printf("MeteoriC 6502 Epoch Timer (mepoc)\n\n");
    printf("Usage: %s [[@|%%]now | YYMMDDHHMM | @aaaaa | %%00000] ...\n", argv[0]);
    printf("       -w [days (default 30)] == find words\n");
    printf("                   @=Base-26, %%=Base-36\n\n");
    process(time(NULL));
    return 0;
  }

  // --- find words
  if (argc > 1 && strcmp(argv[1], "-w") == 0) {
    long now_min = (time(NULL) - START_EPOCH) / 60;
    
    int days = (argc > 2) ? atoi(argv[2]) : 30;
    find_words(now_min, days, now);
    return 0;
  }
    
  // --- convert arguments
  for (int i = 1; i < argc; i++) {
    char *input = argv[i];
    // @/% prefixed input
    if (strcmp(input+1, "now") == 0) {
      process_type(time(NULL), input[0]);
    } else if (strcmp(input, "now") == 0) {
      process(time(NULL));
    } else if (input[0] == '@') {
      process(START_EPOCH + from_base(input + 1, 26) * 60);
    } else if (input[0] == '%') {
      process(START_EPOCH + from_base(input + 1, 36) * 60);
    } else if (strlen(input) == 10) {
      struct tm tm_in = {0};
      sscanf(input, "%2d%2d%2d%2d%2d", &tm_in.tm_year, &tm_in.tm_mon, &tm_in.tm_mday, &tm_in.tm_hour, &tm_in.tm_min);
      tm_in.tm_year += 100; tm_in.tm_mon -= 1; tm_in.tm_isdst = -1;
      process(mktime(&tm_in));
    }
  }
  return 0;
}
