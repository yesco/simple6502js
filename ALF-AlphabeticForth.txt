  ALF - ALphabetic Forth ALF
  =====================
  
  The purpose of ALF is to replace SWEET16
  as an embedded 16-bit language. I found that
  SWEET16 felt too limited and started designing
  another virtual machine for the 6502. A
  register machine. Then I tought, it wouild be 
  nice to have tokens for additional more
  advanced user subroutines that were readable.
  An embedded token language inside a VM with
  new binary register instructions. Eventually,
  I lost interest in register machines and
  instead focussed on a "one letter" Forth.

  Forth is easy to implement; more difficult
  to program. But, it provides a very simple
  and generic way of making functions interact
  with each-other; a universial calling
  and parameter-passing, as well as temporary
  storage, without messing with registers and
  memory locations.

  The grounding principle of ALF is that most
  (common) Forth CORE functions are mapped to
  a single character token in the range 32-95
  (64 characters), basically all readable
  characters of ASCII. Only upper case
  letters are used. (TODO: change)
 
  The idea behind this is to use a token
  based interpreter, instead of subroutine or
  direct threaded, i.e. no general inlining
  of calling addresses or generating (6502)
  JSR/JMP codes.

  This is a well-know and compact way of
  storing common/basic tokens, and to
  implement a simple array lookup to find the
  actual code.

  This also can "co-exist" with machine code.
  It's a pitty, while 6502 only has 52
  instructions with 8 modes giving a total
  of 151 valid instructions (op-codes), this
  leaves 105 free. Most in the bit pattern of
  'xxxx xx11' (64 of them). Sadly enough,
  these are not "nice". I've decided to play
  a game where I use 64 characters as inline
  tokens.

  We use a single main lookup table from the
  character to get an address that we execute.
  Each word ends with jumping to next (3 bytes,
  but fast!), or RTS if it's reused internally
  (slower but code saving).

  Some Forth functionality is hidden behind a
  secondary dispatch using a second character.
  
  For example, all string functions are prefixed
  by '$'.

  .         print number
  $.        print string

  The secondary dispatch may just be chained
  CMP '.'; BNE *; ... which is slow, but easy.
  Or the 'codtab' function may choose to generate
  an 'assaoc' list that is searched that returns
  a single byte offset that is added to the PC.
  We also need a "didn't match" default clause,
  to either give error, or just process next
  token.

  User defined functions, may be single letter,
  alternative case (probably uppercase).

  For example, we may add an 'g' user defined
  op-code. Behind it hides several functions:

    graphics:     ('g' opcode - eXtra Graphics)
      ALF_nextchar
      ALF_adispatch (assoc)
        'L' &line
        'P' &pixel
        'G' &goto
        'C' &circle
        'R' &rectangle
      00
      (default:)
      putc
      fail "%% No such graphics command!"
      RTS
    line: ...
    pixel: ...
    goto: ...
    circle: ...
    ...
    
    OR
      ALF_nextchar
      ALF_tdispatch
        "LPGCR"
        &line &pixel &goto &circle &rectangle
      (Arrive here if no match, A is letter)
      putc
      fail "%% No such graphics command!"
      RTS
      ...
            
  Indeed this method is employed by a number
  of core functions. Here are the letters
  that are effected: '#$?(0-9:;AC:R[]"

  Here is how to use it:

  Normal Forth with spaces:
  
    : DOUBLE DUP + ;
  
  In ALF:

    :D:d+;
    
  Inded a single space will put us in long-name
  mode, until a ] is encountered.

  To use a "long-name" function:

    : QUADRUPLE DOUBLE DOUBLE ;
    :MUL5:D QUADRUPLE]+; ( 4 1 + )
    :MUL10 QUADRUPLE DOUBLE ;

  WORDS DEFINED

  Arithmetic:
    +   plus
    -   minus
    *   multiply
    /   divide
    %%  mod
    %/  /mod
    %#  /mod10

    =   equal
    <   less than
    >   greater than
  ( >=  not have. Use: <n )

    &   and
    _   or (or if use lowercase map |)
    ^   xor
    n   invert (not) (or if use lowercase ~)
   
    0< 0= 0> 1+ 1- (lol, for free!)
  (     no max / min )

  Stack:
    d   dup
    \   drop
    s   swap
    o   over
    p   pick
    rt  rot
    rl  roll
    t   tuck
  ( p   nip ? )

    ##  depth
    
    e   emit
    .   print number
    $.  print string
    $h  print hex    
    
    r>  r> 
    r<  >r (lol)
    r@  @r
    r!  !r

    r[0-9]>    nr>
    r[0-9]<    n>r


  Numbers:
    #-?[0-9]+
        a decimal number (possibly negative)
        # is optional
    #n  negate
    #t  true -1
  ( #f  false 0 - maybe not needed )
  ( #.  decimal print )
    #r  right justified print number

    #<  shift n steps left
    #>  shift n stops right

    #s  sign
    #a  abs

    #x  max
    #m  min (?)

    #q  square root

  ( #b  base )
    #/% /mod ( n d -- div rest )
  
  Floats:
    f... (reserved)

  Hex:
    $[0-9a-f]{0,4}
        a hex number
    $...

  Strings:
    "
    $.  print hex ($t for type)
    $"  pascal string (counted)
 (  $(...)         )
 (       .( ... )  )

    $=
    $<
    $>
    $?  search
  ( $n= )
  ( $n< )
  ( $n> )

    $s  subst
    $/  /string
    $-  -string
   '$ ' blank string

    $m  move
    $r  replace

    $k  key
    $l  line (accept)

    $t  type
    $w  typewhite

    $l  sliteral

  Memory:
    @
    !

  Char:
    'c  put ascii for c on stack, can be space

    c,  c,
    c!  c!
    c@  c@

  ( c"  counted string )

    cr  cr
    c#  print c n times (c n -- )
    cb  blanks
    co  count (?)
    
    c... more in Compiler section

  Control:
    ?d   ?dup
    rc   recurse

    ]    exit (or use ';'!)
    
    Q    quit
    Q"   quit"

    ?(   if  -1 ?( <then> ] <else> )
    ?n(  dup 0 =  if

    ?=(  over swap = if
    ?<(  over swap < if
    ?>(  over swap > if
    ?<=( ?<n(
    ?>=( ?>n(
    ?=n( <> if
    ?&(
    ?_(
    ?^(
    
  ( ?[0-9](                    )
  (      dup 1 <digit> << & if )

    (... begin / do (counts up from zero!)
    )    again / repeat
    i    index of innnermost loop
    j    index of next level loop
    ?)   while
    ]    leave (go to matching ')')
    ?]   if-leave
    [    next (go back to '(')

  ( #(   numbered for )
  ( ##(  numbered do loop )
  ( $(   loop over chars a pointer )
    
    ]]   unroll-leave
    ]]]  unroll-unroll-leave
    ]]]]...

    ?]]  if-unroll-leave
    ?]]]...

    ?[   if-next

    ?(  if     )   then   ]    exit

    (   begin  )   again  ?]   if-exit
              ?)   until  n?]  while
               )   repeat

    $(  do     $)  loop   #+)  +loop


  Allocation:
    al   allot
    
    am   malloc
    af   free
    ar   resize
    az   size
    a,   heap compile (steal 2 bytes)
    
    ac   alloc chain (push on linked list)
    ad   alloc dictionary (create)

    ak   assoc
    ax   assoc execute
    
    ap   pad

  Compiler / Definitions:
    :
    ;
    ;i
    ;a...  again / tail recurse
    ;tN    tail call N
    ;f...  fallthrough

    vx@    variable 'x' fetch (zp)
    vx!    variable 'x' store (zp)

  ( v+X    inc var X)
  ( v-X    dec var X)

    h      here
    g      gere (memory, lol. use M?)

    ,      ,
    l      literal
    $l     sliteral

    x      execute / eval

    c,     c,
    c'     ' or [']
    cp     postpone
    cd     defer
    cs     state
    ce     see
    cc     create

    [ - immediate,  [[

( 2dup etc: t_W_o)
(   w...  2... )
(   TODO: 2! 2/ 2@ 2drop 2dup 2over 2swap X:2>r X:2r> X:2r@ )

  Input/Output:
    .      print
    e      emit
    #.     number print (same as .)
    $.     hex print
    $t     type (string)
    $k     key 
    $l     line (accept)

  UNUSED:

   ' ' - space (ignore / use for long names?)
    b  - (byte? binary? bit?)
    k  - (key? is $k)
    l  - (literal?)
    m  - (min max move memory?)
    n  - ?
    p  - (nip)
  ( u  - Unsigned )
  ( v  - variable )
  ( w  - 2... )
    y  - (yield if multitasking?)
    z  - fill/erase

  OP CODES (ALphabetic)

001 00000 (32) 31-63 ' '..'?'
    
========================================-
  001 00000 (32) 31-63 ' '..'?'
  010 00000 (32) "@A-Z[\]^_"
  011 00000 (32) "?a-z{|}??" 

NOTES:


COMPILATION IDEAS:
  Immidiates
    :   push (start,0,':') on stack (call c')
    rc  recurse (c:jsr address, leaves on stack)
    ?]  pop, push(@here as backpatch), jmp @xx
    (   push (start,0,'(') on stack
    
    )   pop (start,backpatch,'(')) off stack
    ;   pop (start,backpatch,':')) off stack
    
    If backpatch != 0 write current address
    add that address.

    If before and after compilation stack is
    different (!= 0) give error.

========================================
REFERENCES

    FORTH STANDARD (active website, good quality!)
    - https://forth-standard.org/standard/alpha
    Forth83 (clear summary by MikeOS)
    - http://mikeos.sourceforge.net/handbook-forth.html
    Forth2012 (not so understanable)
    - http://lars.nocrew.org/forth2012/
    Forth79
    - https://www.complang.tuwien.ac.at/forth/fth79std/FORTH-79.TXT
    Gforth
    - ???
    Stable - An extreme fast "forthy" VM:
    (it also uses one letter)
    - https://w3group.de/stable.html
    RetroForth with ColorForth f: namesspaces:
    - http://forthworks.com:9999
