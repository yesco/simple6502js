// generated by grok
char unused_opcodes[] = "\x02\x03\x04\x07\x0B\x0C\x0F\x12\x13\x14\x17\x1A\x1B\x1C\x1F\"#'+2347:;<>?BCDGKOZ[\\]_bcdgkortwz{|\x7F\x80\x82\x83\x87\x8B\x8F\x92\x93\x97\x9B\x9C\x9E\x9F\xA3\xA7\xAB\xAF\xB2\xB3\xB7\xBB\xBF\xC2\xC3\xC7\xCB\xCF\xD2\xD3\xD4\xD7\xDB\xDC\xDF\xE2\xE3\xE7\xEB\xEF\xF2\xF3\xF4\xF7\xFA\xFB\xFC\xFF";
// printable: "#'+2347:;<>?BCDGKOZ[\\]_bcdgkortwz{|
// previously used:
//   #   - low byte from match %d
//   "   - hi  byte       "
//   w?  - take arg from after rule length in array
//   ww  - word   from last %d
//   w+  - word+1       "

// New:
//   []  = generate
//   #,R = apply match rule: ?(R)(,R)* i.e. ,-list
//
//      (TODO: no need #repeat...)
//          H= N ::$1 ,H | N ::$1 |
//   
//   <   = low byte from %d
//   >   = hi  byte    "
//   ww  = word        "
//   w+  = word+1      "
//   w?  = word arg from rule (typically subroutine)
//     (cmp #'>' NC:<  C+Z:>  C:w ) => 6B dispatch
//     (cmp #'?' NC:+  C+Z:?  C:w ) => 6B dispatch

// Matching:
//   \x   = quote next character match it
//   $1-9 = put generated of matching sub rule N
//          (each rule match generatea a val $1)
//   $a-z = put char var... (PEG?)
//   $:1-9 = put var name/address/ref (rel? -3?)
//   $/   = rest is optional
//   $,R  = comma-separated Rs
//   $;R  = semicolon-   "
//   %n   = number
//   %i   = identifier
//   %s   = "string" or 'string' or...
//   %e   = match end! (or end?)
//   {}   = action execute during parse-time (no need :E :X) - not implemented!
//   :E   = new Environment  ! (var def ::$1 )
//   :X   = drop Environment ! (var ref $:1  )
//   :t=int
//         = set match var t(ype)=int (a string)
//   ::$1  = define match in $1 as "variable" (scope?)







