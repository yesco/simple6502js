<!DOCTYPE html>
<html>
<body text="white" bgcolor="black">

<div style='text-align:center'><tt style="color:yellow"><b>ORIC HIRES SCREEN</b></tt></div><br/>

<select id="size">
  <option value="1">1 px</option>
  <option value="2">2 px</option>
  <option value="3">3 px</option>
  <option value="4">4 px</option>
  <option value="5">5 px</option>
  <option value="6">6 px</option>
  <option value="7">7 px</option>
  <option value="8">8 px</option>
  <option value="9">9 px</option>
  <option value="10">10 px</option>
  <option value="11">11 px</option>
  <option value="12">12 px</option>
  <option value="15">15 px</option>
  <option value="20">20 px</option>
  <option value="40">40 px</option>
  <option value="50">50 px</option>
  <option value="cell">cell</option>
</select>

<select id="brush">
  <option value="pixel">thin</option>
  <option value="flat">flat</option>
  <option value="down">down</option>
  <option value="cursive">cursive</option>
  <!--option value="watercolor">watercolor</option-->
  <option value="circle">circle</option>
  <!--option value="chinese">chinese</option-->
  <option value="box">box</option>
</select>

<select id="draw">
  <option value="dutts">dutts</option>
  <option value="spray 50">spray 50%<x/option>
  <option value="spray 25">spray 25%</option>
  <option value="spray 10">spray 10%</option>
  <option value="spray 5">spray  5%</option>
  <option value="spray 1">spray  1%</option>

  <option value="path">path</option>
  <option value="line">line</option>
  <option value="circle">circle</option>
  <option value="disc">disc</option>
  <option value="square">square</option>
  <option value="rect">rect</option>
  <option value="box">box</option>
  <option value="image">image</option>
</select>

<select id="inverse">
  <option value="off">norm</option>
  <option value="on">inv</option>
</select>

<select id="cell">
  <option value="-1">color</option>
  <option value="64">bgcol</option>
  <option value="192">invbg</option>
  <option value="127">fgcol</option>
  <option value="255">invfg</option>
</select>

<select id="action">
  <option value="" selected>action</option>
  <option value="save">save</option>
  <option value="load">load</option>
  <option value="clip">clip</option>
  <option value="erase">erase</option>
  <option value="paper 0">BLK (WHT)</option>
  <option value="paper 1">RED (CYA)</option>
  <option value="paper 2">GRN (MAG)</option>
  <option value="paper 3">YEL (BLU)</option>
  <option value="paper 4">BLU (YEL)</option>
  <option value="paper 5">MAG (GRN)</option>
  <option value="paper 6">CYA (RED)</option>
  <option value="paper 7">WHT (BLK)</option>
  <option value="ink 0">blk (wht)</option>
  <option value="ink 1">red (cya)</option>
  <option value="ink 2">grn (mag)</option>
  <option value="ink 3">yel (blu)</option>
  <option value="ink 4">blu (yel)</option>
  <option value="ink 5">mag (grn)</option>
  <option value="ink 6">cya (red)</option>
  <option value="ink 7">wht (blk)</option>
  <option value="draw 0">blk</option>
  <option value="draw 1">red</option>
  <option value="draw 2">grn</option>
  <option value="draw 3">yel</option>
  <option value="draw 4">blu</option>
  <option value="draw 5">mag</option>
  <option value="draw 6">cya</option>
  <option value="draw 7">wht</option>
</select>

<script>
// - read https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Sending_and_Receiving_Binary_Data

/* - TODO: use? this seems to clip at 4K under chrome/android/termux, neither claim low limit, lol
document.addEventListener('copy', function(e) {
  var str = 'cucumber';
  // You can ignore setting third parameter value
  //e.clipboardData.setData('text', str, true);
  e.clipboardData.setData("text", 'echo "'+btoa(cell)+'" | uudecode', true);
  e.preventDefault();
});
*/

function after(s, needle) {
  var r= s.split(needle);
  return r.length==2? r[1].trim(): null;
}

function parseCommand(cmd) {
  saveUndo(); // TODO: if fail, remove?

  var param= after(cmd, " ");
  var n= colornum(param);
  var nf= colornum(cmd);

  if (cmd.startsWith("draw ")) {
    drawink= n;
    return true;
  }
  if (cmd.startsWith("paper ")) {
    setpaperink(n, ink);
    updatehires();
    return true;
  }
  if (cmd.startsWith("ink ")) {
    setpaperink(paper, n);
    updatehires();
    return true;
  }

//  alert("COMMAND: "+ cmd);

  if (cmd.startsWith("erase")) {
    resethires();
    return true;
  }

  if (cmd.startsWith("undo")) {
    undo(); undo(); // twice because we just added one
    // TODO: redo(); ?
    return true;
  }

  if (cmd.startsWith("redraw")) {
    updatehires();
    return true;
  }

  if (cmd.startsWith("tap")) {
    // This will save:
    // - header, filename
    // - hires screen
    // - 42 bytes garbage (?)
    // - 3x40 chars of last 3 lines of text
    //   this one contains, hires attributes to show hires img, once loaded
    //
    // TODO: however, since we're not in hires mode, charset is "befuddled"!

    var header= new Uint8Array([
      0x16, 0x16, 0x16, 0x16, 0x24, // sync
      0x00, 0x00, // any, any
      0x80, // 0x00=basic, 0x80=assembler/data
      0x00, // 0x00=stop,  0x80=basic autostart, 0xc7=asm autostart

      //0xbf, 0x3f, // end address  0xbf3f HI-LO! END (end hires) - only hires
      0xbf, 0xdf, // end address    0xbfdf HI-LO! END (end hires+42+3 text lines)

      0xa0, 0x00, // start address  0xa000 HI-LO! START

      0x00]); // any
    var filename= (param? param: "hires") + ".tap";
    var lost= "------------------------------------------"; // 42 bytes junk
    // These lines, unless we're in hires-mode, will display garbage!
    var text= "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x1ea"
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\x1eb"
    "cccccccccccccccccccccccccccccccccccccc\x1ec"; // last byte switches to hires!

    var blob = new Blob([header, filename, "\x00", cell, lost, text], {
      type: "binary",
    });

    // remove previous download link so we can use same name again!
    var d= dom("download");
    if (d) d.remove();

    // This seems to be a bad hacky way to get a download, lol, autoclick?
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.id= "download";
    a.download = filename;
    a.href = url;
    a.textContent = "Download "+ filename;
    a.click();
    //if the click() function dosen't work you can try using onclick() funcion like this
    //a.onclick();
    //document.getElementById("content").appendChild(a)

    // clear input field
    dom("input").value= "";
    return true;
  }

  // everything else is tried as a color
  if (!isNaN(nf)) {
    drawink= nf;
    return true;
  }

  // fail
  return false;
}

</script>

<button id="undo" value="undo" onclick="javascript:undo();">undo</button>
<br/>

<canvas id="myCanvas" width="480" height="400" style="border:3px solid #d3d3d3; zoom:1; touch-action: none;">
Your browser does not support the HTML canvas tag.</canvas>
<br/>
<input id="input" size=50 autocomplete=off autocorrect=off />

<script>
// TODO: create an overlay cell grid
// - https://stackoverflow.com/questions/36216561/create-canvas-over-another-canvas
// TODO: 

function dom(name) {
  return document.getElementById(name);
}

var Daction= dom("action"), DactionDef= Daction.value;

Daction.onchange= ()=> {
  var v= Daction.value;
  if (parseCommand(v)) ;
  else alert("action.Not.Implemented.Yet: "+ Daction.value);
  Daction.value= DactionDef;
}

const w= 2, h= 2;
var canvas = dom("myCanvas");
var ctx = canvas.getContext("2d");

//const colors= ["black", "red", "lime", "yellow", "blue", "magenta", "cyan", "white"];
const colors= ["#000", "#f00", "#0f0", "#ff0", "#00f", "#f0f", "#0ff", "#fff"];

function colornum(t) {
  if (t==null) return NaN;
  var n= parseInt(t);
  if (!isNaN(n)) return n;
  // Simple!
  t= t.trim().toLowerCase();
  if (t.startsWith("g")) return 2; // Green
  if (t.startsWith("w")) return 7; // White
  if (t.startsWith("m")) return 5; // Magnenta
  if (t.startsWith("c")) return 6; // Cyan
  if (t.startsWith("y")) return 3; // Yellow
  if (t.includes("k")) return 0; // blacK
  if (t.includes("r")) return 1; // Red
  if (t.includes("u")) return 4; // blUe
  return NaN;
}

// store hires screen as array
var cell= new Uint8Array(200*40);
var paper= 0, ink= 3;
var drawink= 1;

// running data state for graphics during update
var x, y, ci, bg, fg;

function setpaperink(p, i) {
  //alert("set papper ink:"+p+" i:"+i);
  paper= p; ink= i;
  for(ci=0; ci<cell.length; ci+= 40) {
    cell[ci]  = paper+16;
    cell[ci+1]= ink;
  }
  updatehires();
}

function resethires() {
  ci=x=y= 0;
  bg= 0; fg= 7;
  cell.fill(ink);
  setpaperink(paper, ink);
  updatehires();
}

resethires();

function nextcell() {
  if (ci>= 240*40) return;

  var v= cell[ci];
  // colors reset every line
  if (ci%40==0) { bg=0; fg=7; x= 0; }

  var i= v&7;

  // hibit is invert colors
  var vl= v&127;

  if (vl<32) { // attributes
    //alert("vl= "+vl+" i="+i);
    // change color
    if (vl>= 0 && vl< 8) fg= i;
    if (vl>=16 && vl<24) bg= i;

    // draw current attr
    var b= colors[(v&128)? 7-bg: bg];
    //b= 'yellow'; // for debug set yellow
    ctx.fillStyle= b;
    ctx.fillRect(x, y, 6*w, h);
    x+= 6*w;

  } else { // pixels 32..63, 63..127

    var b= colors[(v&128)? 7-bg: bg];
    var f= colors[(v&128)? 7-fg: fg];

    // draw 6 pixels
    for(i=0; i<6; ++i) {
      ctx.fillStyle= (v&1)? f: b;
      ctx.fillRect(x, y, w, h);
      v >>= 1; x+= w;
    }

  }

  if (x>=240*w) { x=0; y+= h; }
  ++ci;
}

function updatehires() {
  x= 0; y= 0; ci= 0;
  while(ci<240*40)
    nextcell();
}

function partialupdate() {
  // only need to update the row
  // this will get right colors and effect
  var oy= Math.floor(ci/40);
  x= 0;
  y= 2*oy;
  ci= 40*oy;
  for(var i=40; i--;) nextcell();
}

// TODO: read image from data
// from - https://stackoverflow.com/questions/667045/get-a-pixel-from-html-canvas

function invert() {
  // get CanvasPixelArray
  var imgd = context.getImageData(x, y, width, height);
  var pix = imgd.data;

  // invert each pixel
  for (var i = 0, n = pix.length; i < n; i += 4) {
    pix[i  ] = 255 - pix[i  ]; // red
    pix[i+1] = 255 - pix[i+1]; // green
    pix[i+2] = 255 - pix[i+2]; // blue
    // i+3 is alpha (the fourth element)
  }

  // Draw ImageData at (x,y)
  context.putImageData(imgd, x, y);
}

//ctx.beginPath();
//ctx.arc(25,25,15,0,2*Math.PI);
//ctx.stroke();
//ctx.fillStyle = "green";
//ctx.fillRect(x+=30,y,w,h);
//c.rect(x+=6, y, w, h);

//////////////////////////////////////////////////////////////////////
// - https://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html

// Set up mouse events for drawing
var drawing = false;
var currentPos = { x:0, y:0 };
var startPos = { x:0, y:0 };

// curset(ox, oy, f)
//   ox, oy is "oric coordinates"
//   f is 0=clear, 1=set, 2=xor, 3=move, 32+color= force color!
//
// TODO: combicolors, like brown? (red+yellow+blue!)

// TODO: ansi-color 6x6x6 rgb mapping?
// - https://en.m.wikipedia.org/wiki/ANSI_escape_code#8-bit
//
// ESC[38;5;⟨n⟩m Select foreground color
//       where n is a number from the table below
// ESC[48;5;⟨n⟩m Select background color
//   0-  7:  standard colors (as in ESC [ 30–37 m)
//   8- 15:  high intensity colors (as in ESC [ 90–97 m)
//  16-231:  6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)
// 232-255:  grayscale from dark to light in 24 steps

function curset(ox, oy, f) {
  ox= Math.floor(ox); oy= Math.floor(oy);
  if (ox<0 || oy<0 || ox>=240 || oy>=200) {
    ci= -1;
    return;
  }
  var cm= 1<<(ox%6);
  ci= Math.floor(ox/6) + oy*40;

  // don't set bits in paper attributes
  var v= cell[ci]&127;
  if (v>=32 && v<32+8) return;

  // steal ink cell and make it ours!
  if (v<8) cell[ci]= 64 | (cell[ci]&128);

  switch(f) {
  case 0: cell[ci] &= ~cm; break;
  case 1: cell[ci] |=  cm; break;
  case 2: cell[ci] ^=  cm; break;
  case 3: return;

  // >=32: over-write color 
  default:
    if (f>=32) {
      var i= ci-1;
      do {
        var c= cell[i]&127;
        // override other ink, or pixels
        if (c>=64 || c<8) {
          cell[i]= f&7;
          break;
        }
        // dont change background
        --i;
        //if (i%40==0) break; // fail
      } while(1);

      // steal ink cell and make it ours!
      if (v<8) cell[ci]= 64 | (cell[ci]&128);

      // draw pixel
      cell[ci] |= cm; break;
    }
  }
}

function changed(pos) {
  ox= Math.floor((pos.x+1)/2);
  oy= Math.floor((pos.y+1)/2);
  var v= 0+dom("cell").value;
  if (v>0) {
    curset(ox, oy, 3);
    cell[ci]= 0+v;
    partialupdate();
  } else 
    drawbrush();
}

function drawbrush() {
  var brush= dom("brush").value;
  var size= 0+dom("size").value;
  var draw= dom("draw").value;
  var spray= (draw.startsWith("spray")?
              0+after(draw, "spray"):
              100)/100.0;
  var f= 32+drawink;
  //var f= drawink==ink? 1: 16+drawink;
  //var f= drawink+16;
  
  switch(brush) {

  case "pixel":
    if (Math.random()<=spray) {
      curset(ox, oy, f);
      partialupdate();
    }
    break;

  case "flat":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) curset(ox-i, oy, f);
    }
    partialupdate();
    break;

  case "down":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox, oy+i, f);
        partialupdate();
      }
    }
    break;

  case "cursive":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox-i, oy+i, f);
        partialupdate();
      }
    }
    break;

  case "circle":
    var radius= size;
    var w= radius, h= radius;
    for(var r= -h; r<=h; ++r) {
      for(var c= -w; c<=w; ++c) {
        if (r*r+c*c<radius*radius
            && Math.random()<=spray)
          curset(ox+c, oy+r, f);
      }
      partialupdate();
    }
    break;

  case "box":
    var w= size, h= size;
    for(var r= -h; r<=h; ++r) {
      for(var c= -w; c<=w; ++c) {
        if (Math.random()<=spray)
          curset(ox+c, oy+r, f);
      }
      partialupdate();
    }
    break;

  }
}

// UNDO/REDO

var undoStack= [];

function saveUndo() {
  undoStack.push(new Uint8Array(cell));
  dom("undo").textContent= "undo:"+undoStack.length;
}

function undo() {
  if (!(undoStack.length)) return;
  cell= undoStack.pop();
  updatehires();
  dom("undo").textContent= "undo:"+undoStack.length;
}

// TODO: change this, no like...

canvas.addEventListener("mousedown", function (e) {
  saveUndo();
  drawing = true;
  currentPos= startPos = getMousePos(canvas, e);
  changed(startPos);
  return false;
}, false);

// good to draw a line, action at end?
canvas.addEventListener("mouseup", function (e) {
  drawing = false;
  return false;
}, false);
  
canvas.addEventListener("mousemove", function (e) {
  currentPos = getMousePos(canvas, e);
  changed(currentPos);
  return false;
}, false);

// Get the position of the mouse relative to the canvas
function getMousePos(canvasDom, mouseEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: mouseEvent.clientX - rect.left,
    y: mouseEvent.clientY - rect.top
  };
}


// Set up touch events for mobile, etc
canvas.addEventListener("touchstart", function (e) {
  mousePos = getTouchPos(canvas, e);
  //alert(mousePos);
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

canvas.addEventListener("touchend", function (e) {
  var mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
}, false);

canvas.addEventListener("touchmove", function (e) {
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

// Get the position of a touch relative to the canvas
function getTouchPos(canvasDom, touchEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: touchEvent.touches[0].clientX - rect.left,
    y: touchEvent.touches[0].clientY - rect.top
  };
}

// Prevent scrolling when touching the canvas
document.body.addEventListener("touchstart", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);

document.body.addEventListener("touchend", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);
document.body.addEventListener("touchmove", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);

//alert("all setup!");

// KEYBOARD

var Dinput= dom("input");

document.body.onkeypress= function(e) {
  Dinput.select();
  Dinput.dispatchEvent(e);
  return false;
}

Dinput.onsubmit= function(e) {
  alert(Dinput.value);
}

Dinput.onchange= function() {
  var cmd= Dinput.value;
  parseCommand(cmd);
  Dinput.value= "";
  return false;
}

</script>

</body>
</html>

