<!DOCTYPE html>
<html>
<body text="white" bgcolor="black">

<div style='text-align:center'><tt style="color:yellow"><b>ORIC HIRES SCREEN</b></tt></div><br/>

<select id="size">
  <option value="1">1 px</option>
  <option value="2">2 px</option>
  <option value="3">3 px</option>
  <option value="4">4 px</option>
  <option value="5">5 px</option>
  <option value="6">6 px</option>
  <option value="7">7 px</option>
  <option value="8">8 px</option>
  <option value="15">15 px</option>
  <option value="20">20 px</option>
  <option value="40">40 px</option>
  <option value="50">50 px</option>
  <option value="cell">cell</option>
</select>

<select id="brush">
  <option value="pixel">thin</option>
  <option value="flat">flat</option>
  <option value="down">down</option>
  <option value="cursive">cursive</option>
  <!--option value="watercolor">watercolor</option-->
  <option value="circle">circle</option>
  <!--option value="chinese">chinese</option-->
  <option value="box">box</option>
</select>

<select id="draw">
  <option value="dutts">dutts</option>
  <option value="spray:50">spray 50%<x/option>
  <option value="spray:25">spray 25%</option>
  <option value="spray:10">spray 10%</option>
  <option value="spray:5">spray  5%</option>
  <option value="spray:1">spray  1%</option>

  <option value="path">path</option>
  <option value="line">line</option>
  <option value="circle">circle</option>
  <option value="disc">disc</option>
  <option value="square">square</option>
  <option value="rect">rect</option>
  <option value="box">box</option>
  <option value="image">image</option>
</select>

<select id="inverse">
  <option value="off">norm</option>
  <option value="on">inv</option>
</select>

<select id="cell">
  <option value="-1">color</option>
  <option value="64" style="text-color:white; blackground-color:black;">black</option>
  <option value="192">white</option>
  <option value="127">yellow</option>
  <option value="255">blue</option>
</select>

<select id="action">
  <option value="" selected>action</option>
  <option value="save">save</option>
  <option value="load">load</option>
  <option value="clip">clip</option>
  <option value="erase">erase</option>
</select>
<br/>

<canvas id="myCanvas" width="480" height="400" style="border:3px solid #d3d3d3; zoom:1; touch-action: none;">
Your browser does not support the HTML canvas tag.</canvas>

<script>
// TODO: create an overlay cell grid
// - https://stackoverflow.com/questions/36216561/create-canvas-over-another-canvas
// TODO: 

function dom(name) {
  return document.getElementById(name);
}

var Daction= dom("action"), DactionDef= Daction.value;
Daction.onchange= ()=> {
  switch(Daction.value) {
  case "erase": if (confirm("Erase image?")) {
    resethires();
    break;
  }
  case "save":
  case "load":
  case "clip":
  default:
    alert("action.Not.Implemented.Yet: "+ Daction.value); break;
  }
  Daction.value= DactionDef;
}

const w= 2, h= 2;
var canvas = dom("myCanvas");
var ctx = canvas.getContext("2d");

const colors= ["black", "red", "green", "yellow", "blue", "magnenta", "cyan", "white"];

// store hires screen as array
var cell= new Uint8Array(200*40);
cell.fill(64);

// running data state for graphics during update
var x, y, ci, bg, fg;

function resethires() {
  ci=x=y= 0;
  bg= 0; fg= 7;
  cell.fill(64);
  updatehires();
}

resethires();

function nextcell() {
  if (ci>= 240*40) return;

  var v= cell[ci];
  // colors reset every line
  if (ci%40==0) { bg=0; fg=7; x= 0; }

  var i= v&7;

  // hibit is invert colors
  var vl= v&127;

  if (vl<32) { // attributes
    //alert("vl= "+vl+" i="+i);
    // change color
    if (vl>= 0 && vl< 8) fg= i;
    if (vl>=16 && vl<24) bg= i;

    // draw current attr
    var b= colors[(v&128)? 7-bg: bg];
    //b= 'yellow'; // for debug set yellow
    ctx.fillStyle= b;
    ctx.fillRect(x, y, 6*w, h);
    x+= 6*w;

  } else { // pixels 32..63, 63..127

    var b= colors[(v&128)? 7-bg: bg];
    var f= colors[(v&128)? 7-fg: fg];

    // draw 6 pixels
    for(i=0; i<6; ++i) {
      ctx.fillStyle= (v&1)? f: b;
      ctx.fillRect(x, y, w, h);
      v >>= 1; x+= w;
    }

  }

  if (x>=240*w) { x=0; y+= h; }
  ++ci;
}

function updatehires() {
  x= 0; y= 0; ci= 0;
  while(ci<240*40)
    nextcell();
}

function partialupdate() {
  // only need to update the row
  // this will get right colors and effect
  var oy= Math.floor(ci/40);
  x= 0;
  y= 2*oy;
  ci= 40*oy;
  for(var i=40; i--;) nextcell();
}

// TODO: read image from data
// from - https://stackoverflow.com/questions/667045/get-a-pixel-from-html-canvas

function invert() {
  // get CanvasPixelArray
  var imgd = context.getImageData(x, y, width, height);
  var pix = imgd.data;

  // invert each pixel
  for (var i = 0, n = pix.length; i < n; i += 4) {
    pix[i  ] = 255 - pix[i  ]; // red
    pix[i+1] = 255 - pix[i+1]; // green
    pix[i+2] = 255 - pix[i+2]; // blue
    // i+3 is alpha (the fourth element)
  }

  // Draw ImageData at (x,y)
  context.putImageData(imgd, x, y);
}

//ctx.beginPath();
//ctx.arc(25,25,15,0,2*Math.PI);
//ctx.stroke();
//ctx.fillStyle = "green";
//ctx.fillRect(x+=30,y,w,h);
//c.rect(x+=6, y, w, h);

//////////////////////////////////////////////////////////////////////
// - https://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html

// Set up mouse events for drawing
var drawing = false;
var currentPos = { x:0, y:0 };
var startPos = { x:0, y:0 };

function curset(ox, oy, f) {
  ox= Math.floor(ox); oy= Math.floor(oy);
  if (ox<0 || oy<0 || ox>=240 || oy>=200) {
    ci= -1;
    return;
  }
  var cm= 1<<(ox%6);
  ci= Math.floor(ox/6) + oy*40;
  switch(f) {
  case 0: cell[ci] &= ~cm; break;
  case 1: cell[ci] |=  cm; break;
  case 2: cell[ci] ^=  cm; break;
  case 3: return;
  }
}

function changed(pos) {
  ox= Math.floor((pos.x+1)/2);
  oy= Math.floor((pos.y+1)/2);
  var v= 0+dom("cell").value;
  if (v>0) {
    curset(ox, oy, 3);
    cell[ci]= 0+v;
    partialupdate();
  } else 
    drawbrush();
}

function drawbrush() {
  var brush= dom("brush").value;
  var size= 0+dom("size").value;
  var draw= dom("draw").value;
  var spray= (draw.startsWith("spray:")?
              draw.split("spray:")[1]:
              100)/100.0;
  
  switch(brush) {

  case "pixel":
    if (Math.random()<=spray) {
      curset(ox, oy, 1);
      partialupdate();
    }
    break;

  case "flat":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) curset(ox-i, oy, 1);
    }
    partialupdate();
    break;

  case "down":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox, oy+i, 1);
        partialupdate();
      }
    }
    break;

  case "cursive":
    for(var i=0; i<size; ++i) {
      if (Math.random()<=spray) {
        curset(ox-i, oy+i, 1);
        partialupdate();
      }
    }
    break;

  case "circle":
    var radius= size;
    var w= radius, h= radius;
    for(var r= -h; r<=h; ++r) {
      for(var c= -w; c<=w; ++c) {
        if (r*r+c*c<radius*radius
            && Math.random()<=spray)
          curset(ox+c, oy+r, 1);
      }
      partialupdate();
    }
    break;

  case "box":
    var w= size, h= size;
    for(var r= -h; r<=h; ++r) {
      for(var c= -w; c<=w; ++c) {
        if (Math.random()<=spray)
          curset(ox+c, oy+r, 1);
      }
      partialupdate();
    }
    break;

  }
}

// TODO: redo this, no like...

canvas.addEventListener("mousedown", function (e) {
  drawing = true;
  currentPos= startPos = getMousePos(canvas, e);
  changed(startPos);
  return false;
}, false);

// good to draw a line, action at end?
canvas.addEventListener("mouseup", function (e) {
  drawing = false;
  return false;
}, false);
  
canvas.addEventListener("mousemove", function (e) {
  currentPos = getMousePos(canvas, e);
  changed(currentPos);
  return false;
}, false);

// Get the position of the mouse relative to the canvas
function getMousePos(canvasDom, mouseEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: mouseEvent.clientX - rect.left,
    y: mouseEvent.clientY - rect.top
  };
}


// Set up touch events for mobile, etc
canvas.addEventListener("touchstart", function (e) {
  mousePos = getTouchPos(canvas, e);
  //alert(mousePos);
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

canvas.addEventListener("touchend", function (e) {
  var mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
}, false);

canvas.addEventListener("touchmove", function (e) {
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
  return false;
}, false);

// Get the position of a touch relative to the canvas
function getTouchPos(canvasDom, touchEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: touchEvent.touches[0].clientX - rect.left,
    y: touchEvent.touches[0].clientY - rect.top
  };
}

// Prevent scrolling when touching the canvas
document.body.addEventListener("touchstart", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);

document.body.addEventListener("touchend", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
  return false;
}, false);
document.body.addEventListener("touchmove", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);

//alert("all setup!");

</script>

</body>
</html>

