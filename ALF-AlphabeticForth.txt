  ALF - ALphabetic Forth ALF
  =====================
  
  The purpose of ALF is to replace SWEET16
  as an embedded 16-bit language. I found that
  SWEET16 felt too limited and started designing
  another virtual machine for the 6502. A
  register machine. Then I tought, it wouild be 
  nice to have tokens for additional more
  advanced user subroutines that were readable.
  An embedded token language inside a VM with
  new binary register instructions. Eventually,
  I lost interest in register machines and
  instead focussed on a "one letter" Forth.

  Forth is easy to implement; more difficult
  to program. But, it provides a very simple
  and generic way of making functions interact
  with each-other; a universial calling
  and parameter-passing, as well as temporary
  storage, without messing with registers and
  memory locations.

  The grounding principle of ALF is that most
  (common) Forth CORE functions are mapped to
  a single character token in the range 32-95
  (64 characters), basically all readable
  characters of ASCII. Only upper case
  letters are used. (TODO: change)
 
  The idea behind this is to use a token
  based interpreter, instead of subroutine or
  direct threaded, i.e. no general inlining
  of calling addresses or generating (6502)
  JSR/JMP codes.

  This is a well-know and compact way of
  storing common/basic tokens, and to
  implement a simple array lookup to find the
  actual code.

  This also can "co-exist" with machine code.
  It's a pitty, while 6502 only has 52
  instructions with 8 modes giving a total
  of 151 valid instructions (op-codes), this
  leaves 105 free. Most in the bit pattern of
  'xxxx xx11' (64 of them). Sadly enough,
  these are not "nice". I've decided to play
  a game where I use 64 characters as inline
  tokens.

  We use a single main lookup table from the
  character to get an address that we execute.
  Each word ends with jumping to next (3 bytes,
  but fast!), or RTS if it's reused internally
  (slower but code saving).

  Some Forth functionality is hidden behind a
  secondary dispatch using a second character.
  
  For example, all string functions are prefixed
  by '$'.

  .         print number
  $.        print hex
  $t        print string

  The secondary dispatch may just be chained
  CMP '.'; BNE *; ... which is slow, but easy.
  Or the 'codtab' function may choose to generate
  an 'assaoc' list that is searched that returns
  a single byte offset that is added to the PC.
  We also need a "didn't match" default clause,
  to either give error, or just process next
  token.

  User defined functions, may be single letter,
  alternative case (probably uppercase).

  In ALF:

    :D:d+;
    
  WORDS DEFINED

  Arithmetic:
    +   +
    -   -
    *   *
    /   /
    %%  mod
    %/  /mod
    %#  /mod10

    n   negate

    =   =
    <   <
    >   >
  ( >=  don't have. Use: <n )

    &   and
    |   or (or if only used uppoer case _)
    ^   xor
    ~   invert
   
  (     no max / min )

  Stack:
    d   dup
    \   drop
    s   swap
    o   over
    p   pick
    rt  rot
    rl  roll
  (     tuck )
  (     nip )

    ##  depth
    
    e   emit
    .   print
    $.  hex

    r>  r> 
    r<  >r (lol)
    r@  r@
    r!  r!

    r[0-9]>    nr>
    r[0-9]<    n>r


  Numbers:
    #-?[0-9]+
        a decimal number (possibly negative)
        # is optional
    #n  negate
    #-1  -1
    #t  true -1
  ( #f  false 0 - maybe not needed )
  ( #.  decimal print )
    #r  u.r right justified print number
    #w  within

    #<  lshift n steps left
    #>  rshift n stops right

    #s  sign
    #a  abs

    #x  max
    #m  min (?)

    #q  sqrt

  ( #b  base )
    #/% /mod ( n d -- div rest )
  
  Unsigned
    u.   u.
    u<   u<
   (     um* )
   (     um/mod  )
  
  Floats:
    f... (reserved)

  Hex:
    $[0-9a-f]{0,4}
        a hex number
    $.  print-hex number

  Strings:
    "   s"
    $"  c" pascal string (counted)
 (  $(...)  .( ... )  )

    $=
    $<
    $>
    $?  search
  ( $n= )
  ( $n< )
  ( $n> )

    $s  subst
    $/  /string
    $-  -string
   '$ ' blank string

    $m  move
    $r  replace

    $k  key
    $k  key?
    $l  line (accept)

    $t  type
    $w  typewhite

    $l  sliteral

  Memory:
    @  @
    !  !

  Char:
    'c  char
    '_  bl

    c,  c,
    c!  c!
    c@  c@

  ( c"  counted string )

    cr  cr
    c#  print c n times (c n -- )
    cb  blanks
    co  count (?)
    
    c... more in Compiler section

  Control:
    ?d   ?dup
    rc   recurse

    ]    exit (or use ';'!)
    ]    leave
    ]    unloop
    
    q    quit
    q"   quit"
    rt   throw
    re   catch (errcatch)

    ?(   if_-1_?__<then>_]_<else>_
    ]    else
    )    then

    ?(   if
    ?]   if-exit/leave
    ?]]  if-unroll-exit
    ?[   if-next
    
   Chainables (redundant - nah?)
    ?=(  over_swap_=_if
    ?<(  over_swap_<_if
    ?>(  over_swap_>_if
    ?<=( ?<n(
    ?>=( ?>n(
    ?=~( <>_if
    ?+(  positive 7d0>?(3) == 7?+(3) == 7 3
    ?-(  negative
    ?~(
    ?&(
    ?|(
    ?^(
    
  ( ?[0-9](                    )
  (      dup 1 <digit> << & if )

    #(   for
    #)   loop
    #+)  +loop

    (... begin / do (counts up from zero!)
    )    again / repeat
    i    index of innnermost loop
    j    index of next level loop
    ?)   while
    ]    leave (go to matching ')')
    ?]   if-leave
    [    next (go back to '(')

  ( #(   numbered for )
  ( ##(  numbered do loop )
  ( $(   loop over chars a pointer )
    
    ]]   unroll-leave
    ]]]  unroll-unroll-leave
    ]]]]...

    ?]]  if-unroll-leave
    ?]]]...

    ?[   if-next

    ?(  if     )   then   ]    exit

    (   begin  )   again  ?]   if-exit
              ?)   until  n?]  while
               )   repeat

    $(  do     $)  loop   #+)  +loop


  Allocation:
    al   allot
    
    am   malloc
    af   free
    ar   resize
    az   size
    a,   heap compile (steal 2 bytes)
    
    ac   alloc chain (push on linked list)
    ad   alloc dictionary (create)

    ab   abort
    ab"  abort"

    ak   assoc
    ax   assoc execute
    
    ap   pad

  Compiler / Definitions:
    :       def of single letter word
    ;      "return" end of def
    ;i
    ;a...  again / tail recurse
    ;tN    tail call N
    ;f...  fallthrough

    [      [
    ]      ]

    vx@    variable 'x' fetch (zp)
    vx!    variable 'x' store (zp)

  ( v+X    inc var X)
  ( v-X    dec var X)

    h      here
    g      gere (memory, lol. use M?)

    ,      ,
    r,     -, reverse comma = #-2 al @
    $l     sliteral

    xx     execute (t - ?)
    xe     eval (s - ?)
    xs     subroutine (JSR) (a x y p A - a x y p)
    xa     jump address (JMP) (a x y p A - a x y p)
    xr     return (RTS / quit?)
    
    c,     c,
    c'     ' or [']
    cp     postpone
    cd     defer
    cl     literal (or $l)
    cs     state
    ce     see
    cc     create

    [ - immediate,  [[

( 2dup etc: t_W_o)

    w!  2!
    w/  2/
    w*  2*
    w@  2@
    w\  2drop
    wd  2dup
    wo  2over
    ws  2swap
    wr< 2>r
    wr> 2r>
    wr@ 2r@

  Input/Output:
    .      print
    e      emit
    #.     number print (same as .)
    $.     hex print
    $t     type (string)
    $k     key 
    $l     line (accept)


  Locals:
    3{     nlocals = 3dr<#(,)r>,
    }      dealloc_locals = r,2*nal
    la     first_local
    lb     second_local
    lx     x:th local     == h2-@'x'a-2*@
    l!x    set x:th local == h2-@'x'a-2*!
    
    {abc--ignore|code}
    {      locals (3 2 * d al r<)
    }      deallocates (r> #n al)
    lx     value of local x
    l!x    store value in local x
    
  UNUSED:

   ' ' - space (ignore or use for longnames?)
    `  - (backtick special quoting function?)
    b  - (byte? binary? bit?)
    k  - (key? is $k)
    l  - (la=local a)
    m  - (min max move memory?)
    n  - (negate not=~ nip=sd)
  ( t  - to x='x! tuck=so)
  ( u  - Unsigned prefix)
  ( v  - variable value)
  ( w  - 2... )
    y  - (yield if multitasking?)
    z  - fill/erase

  SUMMARY
   174 words (standard + some extra)
       choosen words
             (   133        49     ) = 182 total
             
    44 single letter
   123 two letters

    58 NOT MAPPED:
       
       #>       #$      hold     <#

       */        */mod   /mod     fm/mod
       m*        sm/rem  um*      um/mod  

       ."        s"      +!      
       
       environment?

       s>d       >number 
       
       word      [']      [char]
       find      compile,

       >in       

       base      decimal

       constant  variable 

    Extended words

       .(       .R       :noname   action-of  

       refill   restore-input   save-input
       source   source-id       buffer:
       
       to       value

       defer    defer!   defer@

       case     endcase  of    endof

       hex      holds    is

       marker   unused   

       nip      parse    parse-name
       tuck     [compile]

       s\"

     8 DON'T NEED

       0<       0=      1+      1-
       0<>      0>      <>      \

       >align   cell+   cells   char+

      



01 00000 (32) 31-63 ' '..'?'
    
========================================-
Ideas for adding long name words:

  Inded a single space will put us in long-name
  mode, until a ] is encountered.

  To use a "long-name" function:

    : QUADRUPLE DOUBLE DOUBLE ;
    :MUL5:D QUADRUPLE]+; ( 4 1 + )
    :MUL10 QUADRUPLE DOUBLE ;

  For example, we may add an 'g' user defined
  op-code. Behind it hides several functions:

    graphics: ('g' opcode - eXtra Graphics)
      ALF_nextchar
      ALF_adispatch (assoc)
        'L' &line
        'P' &pixel
        'G' &goto
        'C' &circle
        'R' &rectangle
      00
      (default:)
      putc
      fail "%% No such graphics command!"
      RTS
    line: ...
    pixel: ...
    goto: ...
    circle: ...
    ...
    
    OR
      ALF_nextchar
      ALF_tdispatch
        "LPGCR"
        &line &pixel &goto &circle &rectangle
      (Arrive here if no match, A is letter)
      putc
      fail "%% No such graphics command!"
      RTS
      ...
            
  Indeed this method is employed by a number
  of core functions. Here are the letters
  that are effected: '#$?(0-9:;AC:R[]"

  Here is how to use it:

  Normal Forth with spaces:
  
    : DOUBLE DUP + ;
  



========================================
  001 00000 (32) 31-63 ' '..'?'
  010 00000 (32) "@A-Z[\]^_"
  011 00000 (32) "?a-z{|}??" 

NOTES:


COMPILATION IDEAS:
  Immidiates
    : push (start,0,':') on stack (call c')
    rc recurse (c:jsr address, leaves on stack)
    ?] pop, push(@here as backpatch), jmp @xx
    ( push (start,0,'(') on stack
    
    ) pop (start,backpatch,'(')) off stack
    ; pop (start,backpatch,':')) off stack
    
    If backpatch != 0 write current address
    add that address.

    If before and after compilation stack is
    different (!= 0) give error.

========================================
REFERENCES

    FORTH STANDARD (active website, good quality!)
    - https://forth-standard.org/standard/alpha
    Forth83 (clear summary by MikeOS)
    - http://mikeos.sourceforge.net/handbook-forth.html
    Forth2012 (not so understanable)
    - http://lars.nocrew.org/forth2012/
    Forth79
    - https://www.complang.tuwien.ac.at/forth/fth79std/FORTH-79.TXT
    Gforth
    - ???
    Stable - An extreme fast "forthy" VM:
    (it also uses one letter)
    - https://w3group.de/stable.html
    RetroForth with ColorForth f: namesspaces:
    - http://forthworks.com:9999

    Forth words defined in Forth:
    - https://github.com/flagxor/eforth/blob/main/ueforth/common/boot.fs
    
