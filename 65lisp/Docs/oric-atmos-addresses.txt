;;; from ORIC: Summary of ROM addrsses
;;; $c58c : Input a line.
;;; $c5e9 : Wait for a keypress and return the ASCII codel.
;;; $d499 : Integer to floating point.
;;; $d99c : Floating point to integer.
;;; $dced : Multiply the accumulator with memoryh.
;;; $dd61 : Move memory to the second accumulator.
;;; $dda7 : Multiply the accumulator by 10.
;;; $ddc3 : Divide the accumulator by 10.
;;; $dde4 : Divide memory by the accumulator.
;;; $dde9 : Divide the second accumulator by the main accumulator.
;;; $de77 : Move memory to the main accumulator
;;; $dead : Move the accumulator to memory.
;;; $ded6 : Move the second accumulator to the main accumulator.
;;; $dee5 : Move the main accumulator to the second accumulator.
;;; $dfe7 : Input a floating-point number from a string of ASCII characters.
;;; $e0d5 : Ouput a floating-point number into a string of ASCII characters.
;;; $e5f5 : Clear the top line.
;;; $e5ea : Print message at far left of top line.
;;; $e790 : Compare filenames.
;;; $eb78 : Read a key without waiting.
;;; $f77c : Output character from X register to screen.
;;; $f865 : Output message to the top line at position X.
;;; $f523 : Poll keyboard.
;;; $f5c1 : Output character to printer.
;;; $f8d0 : Set up the ASCII character set.

;;; ORIC routines can use for MINIMAL
;;; C3F8 (C3F4) - A block move.
;;; C483 (C47C) - Input and process a line.
;;; C59C (C58C) - Input a line.Input a line.
;;; DDA3 (DDA7) - 

;;; - memcpy (27 B) from: $0c to $0e coutn in $10/$11
;;; 
;;; EDC4 A2 00 LDX #$00  This routine transfers a block 
;;; EDC6 A0 00 LDY #$00  of data using #0C as the 
;;; EDC8 C4 10 CPY $10   source pointer and #0E as the 
;;; EDCA D0 04 BNE $EDD0 destination pointer. The 
;;; EDCC E4 11 CPX $11   length of data to be moved is 
;;; EDCE F0 0F BEQ $EDDF held in locations #10/#11.


;;; -- PRINT INTEGER IN A,X.
;;; E0C5 85 D1 STA $D1 
;;; E0C7 86 D2 STX $D2 Save integer in mantissa of
;;; E0C9 A2 90 LDX #$90 main FPA. Set exponent to 16.
;;; E0CB 38 SEC Set sign to positive.
;;; E0CC 20 31 DF JSR $DF31 Normalise main FPA

;;; - GET NUMBER
;;; DFE7 A0 00 LDY #$00 GET NUMBER.
;;; DFE9 A2 0A LDX #$0A Clear section of memory from 
;;; DFEB 94 CC STY $CC,X $CC to $D6 inclusive.

;;; - INT
;;; DFBD A5 D0 LDA $D0 INT
;;; DFBF C9 A0 CMP #$A0 If number is over 2A32 then it 
;;; DFC1 B0 20 BCS $DFE3 is integer already. 
;;; DFC3 20 8C DF JSR $DF8C Convert to integer.

;;; - udiv16 (0c00/???) used by graphics line
;;; EFC8 48 PHA This is a division routine 
;;; EFC9 8A TXA that is used to calculate the 
;;; EFCA 48 PHA slope of a line being drawn. 
;;; EFCB 98 TYA 
;;; EFCC 48 PHA The routine acts on 16 bit 
;;; EFCD A9 00 LDA #$00 numbers. 
;;; EFCF 85 0E STA $0E 
;;; EFD1 85 0F STA $0F Divisor is in #0200/1 and 
;;; EFD3 A2 10 LDX #$10 dividend is in #0C/0D. Must be 
;;; EFD5 06 0C ASL $0C set before routine is called. 
;;; EFD7 26 0D ROL $0D The quotient ends up in #0C/0D 
;;; EFD9 26 0E ROL $0E and the remainder in #0E/0F. 
;;; EFDB 26 0F ROL $0F 
;;; EFDD A5 0E LDA $0E A, X and Y are unaffected by 
;;; EFDF 38 SEC this routine.

;;; - lookup key from key code
;;; F4EF AD 09 02 LDA $0209 CONVERT KEY TO ASCII CODE

;;; - putc (335 B)
;;; 
;;; additional: 32 Bytes jmp table!
;;; 
;;; F602 29 1F AND #$1F CONTROL CHARACTER ROUTINE.
;;; ...
;;; F71A A0 27 LDY #$27 CLEAR CURRENT LINE.
;;; ...
;;; F730 60 RTS
;;; ^^^^ end

;;; +++  !!!!!!!!!! (- #xf816 #xf77c) = 154 B
;;; - putc (+ 154 335) = 489!!!
;;; F77C 48 PHA PRINT CHAR TO SCREEN (in X).
;;; ... (lots of stuff!!!)
;;; F815 60 RTS

;;; - mul40 (47 B)
;;; F731 A0 00 LDY #$00 This routine multiplies the 
;;; F733 8C 63 02 STY $0263 content of the accumulator by 
;;; F736 8D 64 02 STA $0264 #28 (40). Y holds the high 
;;; F739 0A ASL A byte of the result. The page 
;;; F73A 2E 63 02 ROL $0263 2 locations store temporary
;;; F73D 0A ASL A results.
;;; ...
;;; F759 60 RTS 

;;; - atoi (but on error jumps BASIC, lol)
;;; ( no over 25*256 ??? - it's for line numbers?)
;;; CAE2 A2 00 LDX #$00 GET 2 BYTE INTEGER FROM TEXT.


;;; 33 - printd (smallest I found), but only DECIMAL

;;; 24 - atoi (+25 ='-' ?), itoaloop 11! Y=nchar, +13 buffreverse
;;; -- maybe this can be made more generic?
;;; 24 - udiv10 - ORIC
;;; -- baically it's a udiv16by8bits

;;; itoa() udiv10() - 24B - https://github.com/Oric-Software-Development-Kit/osdk/blob/master/osdk/main/Osdk/_final_/lib/itoa.s

;;; TODO: math - floating point??? LOL
;;; log log10 exp fabs cos sin tan atn sqrt pow modf horner
;;; - https://github.com/Oric-Software-Development-Kit/osdk/blob/master/osdk/main/Osdk/_final_/lib/math.s

;;; rand, random(), srandom()
;;; -  https://github.com/Oric-Software-Development-Kit/osdk/blob/master/osdk/main/Osdk/_final_/lib/rand.s

;;; RULES: memcpy/set can do inline for some fixed nubmers!
;;; 19 - memcpy selfmodifying code
;;; memset(), memcpy() - https://github.com/Oric-Software-Development-Kit/osdk/blob/master/osdk/main/Osdk/_final_/lib/memcpy.s - very fast
;;; 
;;;
