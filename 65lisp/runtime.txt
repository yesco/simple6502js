; The source of this is generated by 
; perl autodoc.pl and then MASSAGED and ORDERED

; Basically, can see this as "bytecode" ops of cc65




--- MATH


_abs            - negation on ints


aslax1          - Scale the primary register
aslax2          - Scale the primary register by 4
aslax3          - Scale the primary register by 8
aslax4          - Scale the primary register by 16
aslax7          - Scale the primary register by 128, unsigned

aslaxy          - left shift support for ints and unsigneds

asleax1         - Scale the 32 bit primary register by 2
asleax2         - Scale the 32 bit primary register by 4
asleax3         - Scale the 32 bit primary register by 8
asleax4         - Scale the 32 bit primary register by 16


asrax1          - Scale the primary register
asrax2          - Scale the primary register by 4
asrax3          - Scale the primary register by 8
asrax4          - Scale the primary register by 16
asrax7          - Scale the primary register by 128, signed

asraxy          - right shift support for ints

asreax1         - Scale the primary register
asreax2         - Scale the 32 bit primary register by 4
asreax3         - Scale the 32 bit primary register by 8
asreax4         - Scale the 32 bit primary register by 16


shlax1          - Scale the primary register
shlax2          - Scale the primary register by 4
shlax3          - Scale the primary register by 8
shlax4          - Scale the primary register by 16
shlax7          - Scale the primary register by 128, unsigned

shlaxy          - left shift support for ints and unsigneds


shrax1          - Scale the primary register
shrax2          - Scale the primary register by 4
shrax3          - Scale the primary register by 8
shrax4          - Scale the primary register by 16
shrax7          - Scale the primary register by 128, unsigned

shraxy          - right shift support for unsigneds



negax           - negation on ints
negeax          - negation on longs

bnega           - boolean negation
bnegax          - boolean negation
bnegeax         - boolean negation for longs

complax         - integer complement
compleax        - long complement



--- MATH:  MUL / DIV

deceaxy         - Decrement eax by value in Y


idiv32by16r16   - 32by16 => 16 signed division


imul16x16r32    - 16x16 => 32 signed multiplication
imul8x8r16      - 8x8 => 16 signed multiplication
imul8x8r16m     - 8x8 => 16 signed multiplication

mul32           - multiplication for long (unsigned) ints
mul8x16         - multiplication for ints. Short versions.
mul8x16a        - multiplication for ints. Short versions.
mul8x8          - multiplication for ints. Short versions.

mul32           - multiplication for long (unsigned) ints
mul8x16         - multiplication for ints. Short versions.
mul8x16a        - multiplication for ints. Short versions.
mul8x8          - multiplication for ints. Short versions.



--- REGISTERS

incax4          - Increment ax by value in y
incaxy          - Increment ax by value in y

ldaxi           - Load ax indirect from address in ax
ldaxidx         - Load ax indirect from address in ax

ldaxysp         - Load ax from offset in stack
ldeax0sp        - Load a long from somewhere in the stack

ldeaxi          - Load eax indirect from address in ax
ldeaxidx        - Load eax indirect from address in ax

regbank         - zeropage usage
regsave         - zeropage usage

sp              - zeropage usage
sreg            - zeropage usage

tmp1            - zeropage usage
tmp2            - zeropage usage
tmp3            - zeropage usage
tmp4            - zeropage usage

utsteax         - test long in eax

--- TOS STACK

addysp          - Increment the stackpointer by value in y
addysp1         - Increment the stackpointer by value in y


bpushbsp        - Load a from stack slot and push as byte
bpushbysp       - Load a from stack slot and push as byte

cstkchk         - Store eax at the address on top of stack with index


initialsp       - Store eax at the address on top of stack with index


ldau00sp        - Load an unsigned char indirect from pointer somewhere in stack
ldau0ysp        - Load an unsigned char indirect from pointer somewhere in stack
ldaui0sp        - Load an unsigned char indirect from pointer somewhere in stack
ldauiysp        - Load an unsigned char indirect from pointer somewhere in stack
ldax0sp         - Load ax from offset in stack


push0           - Push value in a/x onto the stack
push0ax         - long push


pusha           - Push value in a onto the stack
pusha0          - Push value in a/x onto the stack
pusha0          - Push value in a/x onto the stack
pusha0sp        - Push value in a onto the stack
pushaysp        - Push value in a onto the stack


pushb           - Push word from stack
pushbidx        - Push word from stack
pushbsp         - Load a from stack slot and push as word
pushbysp        - Load a from stack slot and push as word


pushptr1        - Push ptr1 to stack.
pushptr1idx     - Fetch word indirect and push


pushw           - Fetch word indirect and push

pushw0sp        - Load word from stack slot and push
pushwidx        - Fetch word indirect and push
pushwysp        - Load word from stack slot and push


stax0sp         - Store ax at (sp),y
staxysp         - Store ax at (sp),y


staxspidx       - Store a/x indirect into address at top of stack with index

swapstk         - swap ax with TOS


tosadd0ax       - long add
tosadda0        - add ints
tosaddax        - add ints
tosaddeax       - long add


tosand0ax       - and on longs
tosanda0        - and on ints
tosandax        - and on ints
tosandeax       - and on longs


tosaslax        - left shift support for ints and unsigneds
tosasleax       - left shift support for long and unsigned long


tosasrax        - right shift support for ints
tosasreax       - right shift support for longs


tosdiv0ax       - division for signed long ints
tosdiva0        - division for signed ints
tosdivax        - division for signed ints
tosdiveax       - division for signed long ints


toslcmp         - boolean negation for longs

tosmod0ax       - modulo operation for long signed ints
tosmoda0        - modulo operation for signed ints
tosmodax        - modulo operation for signed ints
tosmodeax       - modulo operation for long signed ints

tosmul0ax       - multiplication for long (unsigned) ints
tosmula0        - multiplication for ints. Short versions.
tosmulax        - multiplication for ints
tosmuleax       - multiplication for long (unsigned) ints

tosor0ax        - or on longs
tosora0         - or on ints
tosorax         - or on ints
tosoreax        - or on longs

tosrsub0ax      - long sub reversed
tosrsuba0       - sub ints reversed
tosrsubax       - sub ints reversed
tosrsubeax      - long sub reversed

tosshlax        - left shift support for ints and unsigneds
tosshleax       - left shift support for long and unsigned long
tosshrax        - right shift support for unsigneds
tosshreax       - right shift support for unsigned longs

tossub0ax       - long sub
tossuba0        - sub ints
tossubax        - sub ints
tossubeax       - long sub

tosudiv0ax      - division for long unsigned ints
tosudiva0       - division for unsigned ints
tosudivax       - division for unsigned ints
tosudiveax      - division for long unsigned ints


tosumod0ax      - modulo operation for long unsigned ints
tosumoda0       - modulo operation for unsigned ints
tosumodax       - modulo operation for unsigned ints
tosumodeax      - modulo operation for long unsigned ints

tosumul0ax      - multiplication for long (unsigned) ints
tosumula0       - multiplication for ints. Short versions.
tosumulax       - multiplication for ints
tosumuleax      - multiplication for long (unsigned) ints

tosxor0ax       - xor on longs
tosxora0        - xor on ints
tosxorax        - xor on ints
tosxoreax       - xor on longs

udiv16          - division for unsigned ints
udiv16by8a      - division for unsigned ints
udiv32          - division for long unsigned ints
udiv32by16r16   - 32by16 => 16 unsigned division
udiv32by16r16m  - 32by16 => 16 unsigned division

umul16x16r16    - 16x16 => 32 unsigned multiplication
umul16x16r16m   - 16x16 => 32 unsigned multiplication
umul16x16r32    - 16x16 => 32 unsigned multiplication
umul16x16r32m   - 16x16 => 32 unsigned multiplication
umul8x16r16     - 8x16 => 24 unsigned multiplication
umul8x16r16m    - 8x16 => 24 unsigned multiplication
umul8x16r24     - 8x16 => 24 unsigned multiplication
umul8x16r24m    - 8x16 => 24 unsigned multiplication
umul8x8r16      - 8x8 => 16 unsigned multiplication
umul8x8r16m     - 8x8 => 16 unsigned multiplication


tsteax          - test long in eax
toslong         - Convert tos from int to long
toslong1        - Convert tos from int to long
toslong2        - Convert tos from int to long
tosulong        - Convert tos from int to long

ldeaxysp        - Load a long from somewhere in the stack

leaa0sp         - Load effective address with offset in A/X relative to SP
leaaxsp         - Load effective address with offset in A/X relative to SP

popeax          - long pop

popsreg         - Pop TOS into sreg



--- COMPARE

toseq00         - Compare == for ints
toseqa0         - Compare == for ints
toseqax         - Compare == for ints
toseqeax        - long equal


tosge00         - Compare >= for signed ints
tosgea0         - Compare >= for signed ints
tosgeax         - Compare >= for signed ints
tosgeeax        - Compare >= for long ints


tosgt00         - Compare > for signed ints
tosgta0         - Compare > for signed ints
tosgtax         - Compare > for signed ints
tosgteax        - Compare > for long ints
tosicmp         - Compare > for signed ints
tosicmp0        - Compare > for signed ints


tosle00         - Compare <= for signed ints
toslea0         - Compare <= for signed ints
tosleax         - Compare <= for signed ints
tosleeax        - Compare <= for long ints


toslt00         - Compare < for signed ints
toslta0         - Compare < for signed ints
tosltax         - Compare < for signed ints
toslteax        - Compare < for long ints

tosne00         - Compare != for ints
tosnea0         - Compare != for ints
tosneax         - Compare != for ints
tosneeax        - long not equal

tosuge00        - Compare >= for unsigned ints
tosugea0        - Compare >= for unsigned ints
tosugeax        - Compare >= for unsigned ints
tosugeeax       - Compare >= for long unsigneds

tosugt00        - Compare > for unsigned ints
tosugta0        - Compare > for unsigned ints
tosugtax        - Compare > for unsigned ints
tosugteax       - Compare > for long unsigneds

tosule00        - Compare <= for unsigned ints
tosulea0        - Compare <= for unsigned ints
tosuleax        - Compare <= for unsigned ints

tosuleeax       - Compare <= for long unsigneds
tosulta0        - Compare < for unsigned ints
tosultax        - Compare < for unsigned ints
tosulteax       - Compare < for long unsigneds



--- += on STACK for TOS

addeq0sp        - += operator for ints on the stack
addeqysp        - += operator for ints on the stack

lsubeq          - -= operator
lsubeq0sp       - -= operator for longs on the stack
lsubeq1         - -= operator
lsubeqa         - -= operator
lsubeqysp       - -= operator for longs on the stack

lsubeq          - -= operator
lsubeq0sp       - -= operator for longs on the stack
lsubeq1         - -= operator
lsubeqa         - -= operator
lsubeqysp       - -= operator for longs on the stack


subeq0sp        - -= operator for ints on the stack
subeqysp        - -= operator for ints on the stack



--- CONVERT

booleq          - Make boolean according to flags
boolge          - Make boolean according to flags
boolgt          - Make boolean according to flags
boolle          - Make boolean according to flags
boollt          - Make boolean according to flags
boolne          - Make boolean according to flags
booluge         - Make boolean according to flags
boolugt         - Make boolean according to flags
boolule         - Make boolean according to flags
boolult         - Make boolean according to flags

along           - Convert char in ax into a long

aulong          - Convert char in ax into a long
axlong          - Convert int in ax into a long
axulong         - Convert int in ax into a long

bcasta          - boolean cast
bcastax         - boolean cast
bcasteax        - boolean cast for longs





--- MISC

done            - Support for calling special irq routines declared as condes
done            - add ints

fetch1          - Support for calling module constructors/destructors
fetch2          - Support for calling module constructors/destructors

index           - Support for calling module constructors/destructors
index           - Support for calling special irq routines declared as condes

leave           - function epilogue
leave           - function epilogue
leave0          - function epilogue
leave00         - function epilogue
leavey          - function epilogue
leavey0         - function epilogue
leavey00        - function epilogue

ptr1            - zeropage usage
ptr2            - zeropage usage
ptr3            - zeropage usage
ptr4            - zeropage usage



ret0            - Make boolean according to flags
ret1            - Make boolean according to flags

--- GENERICS

callax          - call function via pointer in ax
callirq         - Support for calling special irq routines declared as condes
callirq_y       - Support for calling special irq routines declared as condes
callptr4        - call function via pointer in ptr4

__argc          - Support for calling special irq routines declared as condes
__argv          - Support for calling special irq routines declared as condes

jmpvec          - Jump vector that resides in the data segment so its address
jmpvec          - Support for calling module constructors/destructors
jmpvec          - Support for calling special irq routines declared as condes

loop            - Support for calling module constructors/destructors
loop            - Support for calling special irq routines declared as condes

lowwater        - Store eax at the address on top of stack with index


--- LONG

laddeq          - += operator
laddeq0sp       - += operator for longs on the stack
laddeq1         - += operator
laddeqa         - += operator
laddeqysp       - += operator for longs on the stack

ldeaxysp        - Load a long from somewhere in the stack

pushax          - push ax onto stack
popax           - pop a value from the stack into ax
incsp2          - drop one value from stack
incsp 1-8       - drop one value from stack
addysp          - base on Y, JSR=drop, JMP=Y..drop RTS



pusheax         - long push
pushl0          - long push

resteax         - save eax into temp storage/restore eax from temp storage
saveeax         - save eax into temp storage/restore eax from temp storage

shleax1         - Scale the 32 bit primary register by 2
shleax2         - Scale the 32 bit primary register by 4
shleax3         - Scale the 32 bit primary register by 8
shleax4         - Scale the 32 bit primary register by 16

shreax1         - Scale the 32 bit primary register by 2
shreax2         - Scale the 32 bit primary register by 4
shreax3         - Scale the 32 bit primary register by 8
shreax4         - Scale the 32 bit primary register by 16

steax0sp        - Store eax at (sp),y
steaxysp        - Store eax at (sp),y
stkchk          - Store eax at the address on top of stack with index

store           - Convert char in ax into a long
store           - Convert int in ax into a long
