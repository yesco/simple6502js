// Generated by grok, lol

#include <cc65.h>  // For basic runtime
#include <conio.h> // For screen output (optional, for status)

// Define buffer at screen memory (e.g., $A000 for hi-res screen dump).
// Use fixed addr to avoid stack/heap issues on 6502.
unsigned char *screen_buffer = (unsigned char *)0xA000;
#define LOAD_SIZE 1024  // e.g., 1K screen; ROM will load up to header size.

// Static array for filename (11 chars + null; placed in data for asm access).
static unsigned char filename[12] = "SCREEN   \0";  // Adjust name; space-padded to 11.

// Custom tape load function: Returns 0 on success, -1 on fail.
// Uses Atmos 1.1 ROM routines: $E5E0 init, $F8A0 header, $FCE4 block load.
// Assumes tape formatted as data block ($10 header type, load addr in header matches dest).
// Loads directly to dest; loops until EOF block ($1A).
int load_tape_data(unsigned char *dest, unsigned int size) {
    unsigned int bytes_loaded = 0;
    unsigned char block_type;
    unsigned char error = 0;
    
    // Inline asm block: Full tape load sequence.
    // Preserves registers where possible; uses zero page temps if needed ($9B-$A3 for ROM vars).
    __asm__ __volatile__ (
        // Init tape: Motor on, wait for leader tone.
        "jsr $E5E0\n"  // Returns A=0 if tone found, else error.
        "bne %[error_out]\n"
        
        // Prepare filename ptr: Low byte in A, high in Y (filename in data seg, assume low mem).
        "lda %w[filename_lo]\n"  // %w for word: lo of label
        "ldy %w[filename_hi]\n"
        
        // Optional: Print filename for user feedback (ROM routine echoes during load).
        // Skip or add: jsr $BFEE (print string at A/Y).
        // "jsr $BFEE\n"  // Prints until $00; assumes uppercase.
        
        // Read header: Verifies name, sets type ($9B), addr ($9C low, $9D hi), size ($9E low, $9F hi).
        "jsr $F8A0\n"  // A=0 ok, else error (bad header/sync/name).
        "bne %[error_out]\n"
        
        // Check type == $10 (data block).
        "lda $9B\n"
        "cmp #$10\n"
        "bne %[error_out]\n"
        
        // Verify header load addr matches dest (optional; for safety).
        // "lda $9C\n"  // Compare to dest lo/hi.
        // "cmp %w[dest_lo]\n"
        // "bne %[error_out]\n"
        // "lda $9D\n"
        // "cmp %w[dest_hi]\n"
        // "bne %[error_out]\n"
        
        // Load loop: Read blocks until EOF ($1A) or error; accumulate bytes.
    "load_loop%=:\n"
        "jsr $FCE4\n"  // Loads size bytes from $9E/$9F to $9C/$9D; verifies checksum.
                        // Returns A=0 ok, $80 checksum fail, $81 timeout, etc.
                        // Updates $9C/$9D += size, $9E/$9F=0 after.
        "bne %[error_out]\n"
        
        // Get next block type (ROM sets $9B? Actually, $FCE4 returns type in... wait, post-load type from next header? 
        // Correction: Oric ROM's full CLOAD loop reads header for each data block? No.
        // Standard: After main header, data is in silent blocks? Actually, for multi-block, it's one header, then data blocks each preceded by short sync + type/addr/size/check.
        // But $FCE4 reads one full data block (type implied from prev).
        // To detect EOF: After load, ROM checks if more data or EOF marker.
        // Simplified: Loop fixed times or until size reached (for single-block common).
        // For full: After $FCE4, if A=0 and size was >0, cont; but EOF is when no more tone or special block.
        // Better: Mimic ROM - loop JSR $FCE4 until A !=0 and not checksum (but ROM loops until timeout/EOF).
        // For accuracy: The ROM's internal loop in CLOAD is at $D0xx, but to replicate:
        // Assume single block for screen (common); for multi, add counter or check remaining size.
        // Here: Loop while bytes < size (user cap).
        
        // Accumulate: lda $9E (last size lo); but since var size, approx.
        // For simplicity: Assume loads to dest, cap at size.
        "lda %[bytes_loaded]\n"
        "clc\n"
        "adc #$40\n"  // Assume ~64B avg block? Better: track total.
        // Note: To exact, before loop: ldx $9F; lda $9E; add to bytes (but multi-word).
        // Skip accum for now; check post-loop.
        
        "lda %[size]\n"  // User size cap.
        "bne %[cont_load]\n"  // Dummy; adjust for loop cond.
        
    "cont_load%=:\n"
        // Check if reached user size (approx; or loop fixed # blocks).
        // For now: Single call to $FCE4 for demo; extend for multi.
        // To loop properly: After $FCE4, JSR $E5E0 again? No.
        // Actual ROM CLOAD loop: After header, do { JSR $FC00-ish; if type==$1A break; } but in Oric, data blocks are chained without new header.
        // Clarify from ROM: The block load $FCE4 reads the data portion after the initial header; for large files, it loops internally or via BASIC loop? 
        // Upon precise: CLOAD reads header ($F8A0), then enters loop: JSR $FCE4 (loads 256B? ), updates addr, until the read fails (no more data, timeout returns error ~$82).
        // Yes: Loop JSR $FCE4 until A !=0 (end of data detected by lack of tone/sync).
        // Then if last A==$82 (normal EOF), ok.
        // So:
        "lda #$82\n"  // Expected EOF code.
    "check_eof%=:\n"
        "jsr $FCE4\n"
        "cmp #$82\n"  // Normal end (no tone).
        "beq %[done]\n"
        "cmp #$00\n"  // Or if checksum ok but size=0?
        "beq %[load_loop]\n"
        "bne %[error_out]\n"  // Any other error.
        
    "done%=:\n"
        "lda #$00\n"
        "sta %[error]\n"
        "jmp %[exit]\n"
        
    "%[error_out]%=:\n"
        "sta %[error]\n"
        
    "%[exit]%=:\n"
        "rts\n"
        : [error] "=a" (error)
        : [filename_lo] "i" ((unsigned int)filename), [filename_hi] "i" (((unsigned int)filename)>>8),
          [dest_lo] "i" ((unsigned int)dest), [dest_hi] "i" (((unsigned int)dest)>>8),
          [bytes_loaded] "i" (bytes_loaded), [size] "i" (size)
        : "a", "x", "y"  // Clobbers
    );
    
    // Post-check: If error==0 and loaded ~size (approx, since no exact track here).
    // For accuracy, after loop, check if dest contents changed or add byte count.
    // ROM loads all until EOF, so if header size >= your size, ok.
    return (error == 0 || error == 0x82) ? 0 : -1;
}

int main(void) {
    clrscr();  // Clear screen.
    gotoxy(0,0);
    cprintf("Loading screen...");
    
    if (load_tape_data(screen_buffer, LOAD_SIZE) == 0) {
        cprintf("Loaded OK. Continuing...");
        // Now your program logic: e.g., the screen is at $A000, process/display.
        // Infinite loop or whatever.
        while(1);  // Placeholder.
    } else {
        cprintf("Load fail!");
        while(1);
    }
    
    return 0;  // Won't reach, but good form.
}
